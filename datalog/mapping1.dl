.include "definitions.dl"

// Basic mapping

//RenameVertex_("Donator","Sponsor"):-
//    Vertex("Donator").
//
//AddVertexProperty_("Team","leader",V):-
//    Vertex("Leader"),
//    Vertex("Team"),
//    Edge("Manages","Leader","Team"),
//    VertexProperty("Leader","name",V).
//
//MoveEdgeSource_("Spends","Team"):-
//    Vertex("Leader"),
//    Vertex("Team"),
//    Edge("Manages","Leader","Team"),
//    Edge("Spends","Leader",_).
//
//RemoveVertex_("Leader"):-
//    Vertex("Leader").

//Variables:
//Donator: Vertex, Dv
//Sponsor: Vertex, Sv
//Team: Vertex, Tv
//leader: Property, lp
//Leader: Vertex, Lv
//Manages: Edge, Me
//name: Property, np
//Spends: Edge, Se

Transformation("Mapping1").

// This predicate is so that we can group tuples together. The idea is that the
// mapping will be applied as a whole, so we want to apply it to each allowed
// assignment of the variables. But, MoveEdgeSource_ and AddVertexProperty_ will
// both generate tuples for each assignment and we will have no way of knowing
// which tuple of MoveEdgeSource_ and AddVertexProperty_ correspond to the same
// assignment. So we use this rule to generate assignments and give them each a
// unique id. Then, each tuple of MoveEdgeSource_ and AddVertexProperty_ generated
// by the same assignemt of the variables will have the same id.
.decl Mapping1(id: number, Dv: unsigned, Sv: unsigned, Tv: unsigned, lp: symbol, Lv: unsigned, Me: unsigned, np: symbol, Se: unsigned)
.output Mapping1

// autoinc() will assign each tuple numerical index.
// The body of this rule is made by putting together all the bodies of the other rules and adding inequality constraints.
// This will lead to duplicated constraints that are both in this rule and in RenameVertex_, by example. But I do not think this is a problem for souffle.
Mapping1(autoinc(), Dv, Sv, Tv, lp, Lv, Me, np, Se):-
    Vertex(Dv),
    TargetVertex(Sv),
    TargetVertexName(Sv,Svn),
    Vertex(Lv),
    Vertex(Tv),
    Edge(Me,Lv,Tv),
    VertexProperty(Lv,np,V),
    TargetVertexProperty(_, lp, _),
    Vertex(Lv),
    Vertex(Tv),
    Edge(Me,Lv,Tv),
    Edge(Se,Lv,_),
    Vertex(Lv),
    Dv != Sv,
    Dv != Lv,
    Sv != Lv,
    Me != Se.

// The first "Mapping1" constant is there so that TransProof can differentiate between tuples from RenameVertex_ that are generated by different mappings.
RenameVertex_("Mapping1", Id, Dv, Svn):-
    Vertex(Dv),
    // Because we are renaming a vertex, we need a name and we cannot take the
    // name from the schema we are transforming. So, for Svn to be grounded, we add
    // these constraints so we chose a name from the target schema.
    TargetVertex(Sv),
    TargetVertexName(Sv,Svn),
    // We get the id of the assignment we are using.
    Mapping1(Id, Dv, Sv, _, _, _, _, _, _).

AddVertexProperty_("Mapping1", Id, Tv,lp,V):-
    Vertex(Lv),
    Vertex(Tv),
    Edge(Me,Lv,Tv),
    VertexProperty(Lv,np,V),
    TargetVertexProperty(_, lp, _),
    Mapping1(Id, _, _, Tv, lp, Lv, Me, np, _).

MoveEdgeSource_("Mapping1", Id, Se,Tv):-
    Vertex(Lv),
    Vertex(Tv),
    Edge(Me,Lv,Tv),
    Edge(Se,Lv,_),
    Mapping1(Id, _, _, Tv, _, Lv, Me, _, Se).

RemoveVertex_("Mapping1", Id, Lv):-
    Vertex(Lv),
    Mapping1(Id, _, _, _, _, Lv, _, _, _).
